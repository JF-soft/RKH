/**
 * 	trace.h
 *
 * 	When a program needs to be traced, it has to generate some information 
 * 	each time it reaches a "significant step" (certain instruction in the 
 * 	program’s source code). In the standard terminology, this step is called 
 * 	a trace point, and the tracing information which is generated at that 
 * 	point is called a trace event. A program containing one or more of this 
 * 	trace points is named instrumented application.
 *
 * 	There are two classes of trace events: user trace events, which are 
 * 	explicitly generated by an instrumented application, and system trace 
 * 	events, which are generated by the operating system.
 * 	
 * 	For system events, the definition of events and the mapping between these 
 * 	events and their corresponding names is hard-coded in the implementation 
 * 	of the trace system. Therefore, this events are common for all the 
 * 	instrumented applications and never change (they are always traced). 
 * 	The system events are associated with a integer value and are explicity 
 * 	listed and defined (enumerated) as shown below.
 * 		
 *	The definition of user events is very different. When an instrumented 
 *	application wants to generate a trace event, it has first to create this 
 *	event. This is done by adding the new trace event within user trace event 
 *	list (enumeration). Similar to system events, user events are associated 
 *	with a integer value. 
 * 	
 *	The standard defines that the trace system has to store some information 
 *	for each trace event being generated, including, at least, the following:
 *
 * 	a.- the trace event type identifier (SYS_TRACE or USRx_TRACE),
 * 	b.- a trace event (enumerated list),
 * 	c.- a timestamp (optional),
 * 	d.- any extra data that the system or the instrumented application 
 * 		wants to associate with the event (optional).
 *
 * 	When the system or an application trace an event, all the information 
 * 	related to it has to be stored somewhere before it can be retrieved, 
 * 	in order to be analyzed. This place is a trace stream. An active 
 * 	trace stream can be of two different types, depending on whether it 
 * 	has been created with or without a log. A log is a persistent object 
 * 	in which the events stored in the stream are saved each time the 
 * 	stream is flushed by the trace system.
 *
 * 	In a trace stream with log, events traced from the target process are 
 * 	stored in the stream until it is flushed.
 *
 * 	In a trace stream without log, trace events are never written to any 
 * 	persistent media, but instead they remain in the stream 
 * 	(in RAM memory) until they are explicitly retrieved. Therefore, an 
 * 	active trace stream without a log is used for on-line analysis of 
 * 	events.
 */


#ifndef __TRACE_H__
#define __TRACE_H__


#include "mytypes.h"
#include "rkassert.h"


/* 
 * 	Enable (1) or Disable (0) trace timestamp 
 */

#define RKSYS_TRACE_TS			1			

/* 
 * 	Enable (1) or Disable (0) print trace events 
 */

#define RKSYS_TRACE_PRINT		0			


/*
 * 	Maximum number of trace events tha the trace stream can contain.
 */

#define NUM_OF_TRACES			16


#if RKSYS_TRACE_TS == 1
#include "rktime.h"
#endif


/* 	
 * 	There are four groups of trace events SYS_TR_TYPE, USR0_TR_TYPE, 
 * 	USR1_TR_TYPE and USR2_TR_TYPE, each one should be configurated
 * 	in runtime. These are used as argument of 'trace_start_stop' and 
 * 	'trace_config' functions.
 */

enum
{
	SYS_TR_TYPE, USR0_TR_TYPE, USR1_TR_TYPE, USR2_TR_TYPE,
	NUM_TRACE_TYPE
};


/*
 * 	Return codes
 */

enum
{
	TRACE_STREAM_OK, TRACE_STREAM_EMPTY, TRACE_STREAM_FULL
};


/*
 * 	Enable or disable a trace group. It's used as argument of 
 * 	'trace_config' function.
 */

enum
{
	TRACE_STOP, TRACE_START
};


/*
 * 	Defines printable or not a trace group. It's used as argument of 
 * 	'trace_config' function.
 */

enum
{
	TRACE_NPRINT, TRACE_PRINT
};


/*
 * 	Defines logged or not a trace group. It's used as argument of 
 * 	'trace_config' function.
 */

enum
{
	TRACE_NLOG, TRACE_LOG
};


/* 	
 *  These macros must be used as a base number within list 
 *  of trace events.
 */

#define SYS_TRACE_EVENT_BASE		0x00	/* 64 trace events */
#define USR0_TRACE_EVENT_BASE		0x40
#define USR1_TRACE_EVENT_BASE		0x80
#define USR2_TRACE_EVENT_BASE		0xC0


/* 
 * 	List of system trace events:
 *
 *	The list below defines the available trace events. The system 
 *	generates each event by using a previously declared macro. Thus, each
 *	event is associated a macro. These macros are placed within RKSYS 
 *	source code, at key points of interest, called trace points. The macro 
 *	parameters are used to indicate which task, queue, mutex, timer or 
 *	event flag register was associated with the event being recorded.
 */

enum
{
	RKTRACE_SYS_USR_EVENT = RKSYS_ASSERT_NUM_ERRORS,

	/* ----- Scheduler trace event ----- */

	RKTRACE_DISPATCH_TASK,

	/* ----- Task trace event ----- */

	RKTRACE_KILL_SUSPEND_TASK,
	RKTRACE_RESUME_TASK,
	RKTRACE_CREATE_TASK,
	RKTRACE_DEPLETE_TASK_QUEUES,
	RKTRACE_TASK_READY,

	/* ----- Event flag register trace event ----- */

	RKTRACE_ASSIGN_EFR,
	RKTRACE_REASSIGN_EFR,
	RKTRACE_FREE_EFR,
	RKTRACE_SET_WAIT_FLAGS,
	RKTRACE_SET_FLAGS,

	/* ----- Mutex trace event ----- */

	RKTRACE_TAKE_MUTEX,
	RKTRACE_GIVE_MUTEX,
	RKTRACE_UNLINK_MUTEX,
	RKTRACE_CREATE_MUTEX,
	RKTRACE_FREE_MUTEX,

	/* ----- Queue trace event ----- */

	RKTRACE_REMOVE_QUEUE,
	RKTRACE_INSERT_QUEUE,
	RKTRACE_READ_QUEUE,
	RKTRACE_DEPLETE_QUEUE,
	RKTRACE_REASSIGN_QUEUE,

	/* ----- Stimer trace event ----- */

	RKTRACE_ASSIGN_TIMER,
	RKTRACE_REASSIGN_TIMER,
	RKTRACE_KILL_TIMER,
	RKTRACE_KICK_TIMER,
	RKTRACE_STOP_TIMER,
	RKTRACE_TIMER_TICK,

	/* ----- FSM trace event ----- */

	RKTRACE_TRANSITION,

	/* ----- Interrupt trace event ----- */

	RKTRACE_INTERRUPT_IN,
	RKTRACE_INTERRUPT_OUT,
};


/* 
 * 	Lists of user trace events:
 *
 *	When an instrumented application wants to generate a trace event, 
 *	it has first to create these events. This is done by adding the new 
 *	trace event within user trace event list (enumeration). Similar to 
 *	system events, user events are associated with a integer value. 
 */

enum
{
	USR0TRACE_T0 = USR0_TRACE_EVENT_BASE,
	/* ... */
};


enum
{
	USR1TRACE_T0 = USR1_TRACE_EVENT_BASE
	/* ... */
};


enum
{
	USR2TRACE_T0 = USR2_TRACE_EVENT_BASE
	/* ... */
};


/*
 * 	System trace macros:
 *
 * 	Key points of interest within the RKSYS source code contain 
 * 	empty macros that an application can re-define for the purpose of 
 * 	proving application specific trace facilities. The application need 
 * 	only implement those macros of particular interest - with unused 
 * 	macros remaining empty and therefore not impacting the application 
 * 	timing.
 *
 * 	Note: the system macros are defined within 'rksys.h' header file section 
 * 	"Trace tool macros".
 */
	 
#define rktrace_init()											\
	trace_init();												\
	trace_config( SYS_TR_TYPE, TRACE_NLOG, TRACE_PRINT );		\
	trace_config( USR0_TR_TYPE, TRACE_LOG, TRACE_PRINT );		\
	trace_config( USR1_TR_TYPE, TRACE_LOG, TRACE_PRINT );		\
	trace_config( USR2_TR_TYPE, TRACE_LOG, TRACE_PRINT )


#define rktrace_sys_start()										\
	trace_start_stop( SYS_TR_TYPE, TRACE_START )


#define rktrace_sys_stop()										\
	trace_start_stop( SYS_TR_TYPE, TRACE_STOP )


#if RKSYS_TRACE_TS == 1
#define rktrace_set_ts( pts )	rktime_gettod( pts )
#else
#define rktrace_set_ts( pts )
#endif


#define rktrace_transition( fsmd, cst, nst )					\
		trace_event0( RKTRACE_TRANSITION, fsmd, cst, nst )


/* ... */


/*
 * 	User trace macros:
 *
 * 	An application can define its trace points. Therefore, it must be define
 * 	its events and macros.
 */

#define rktrace_usr_start( trtype )							\
	trace_start_stop( trtype, TRACE_START )


#define rktrace_usr_stop( trtype )							\
	trace_start_stop( trtype, TRACE_STOP )


#define rktrace_usr_wd()									\
{															\
	rkdisable_interrupt();									\
	rkreset();												\
}


#define rktrace_usr_timer0()								\
	trace_event0( USR0TRACE_T0, 0, 0, 0 )					\


#define rktrace_usr_timer1()								\
	trace_event0( USR1TRACE_T0, 0, 0, 0 )					\


#define rktrace_usr_timer2()								\
	trace_event0( USR2TRACE_T0, 0, 0, 0 )					\


/* ... */


/*
 * 	--------- Internal declarations for trace facility --------- 
 */

typedef struct
{
	uchar event;
	union
	{
		struct
		{
			uchar d0;
			uchar d1;
		} ds0;
		ushort d01;
	} ds;
	uchar d2;
	
	#if RKSYS_TRACE_TS == 1
	RK_TIME_T ts;
	#endif

} TRACE_EVENT_T;


void trace_init( void );
void trace_start_stop( uchar trtype, uchar opt );
void trace_config( uchar trtype, uchar log, uchar print );

void trace_event0( uchar event, uchar d0, uchar d1, uchar d2 );
void trace_event1( uchar event, ushort d01, uchar d2 );

uchar trace_getnext_event( TRACE_EVENT_T *p );
ushort trace_get_status( void );
void trace_flush( void );


#endif
