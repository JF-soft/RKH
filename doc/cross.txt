/**
\page cross_blinky Blinky
\image html rkh_bunner.jpg

\n
Prev: \ref cross "Cross-platform examples"\n\n

The goal of "Blinky" demo application is to explain how to represent a "flat" 
state machine, how to use the timer services, and trace facility from RKH 
framework. To do that is proposed a very simple demo that use one state 
machine and one timer, which is shown and itself explained in the 
\ref blinky_fig1 "Blink a LED state diagram". This is the 'hello world' of 
RKH programming. 

The platform-independent Blinky source code (in C) is located in the 
\c \<rkh\>\\demo\\cross\\blinky\\ directory, where \c \<rkh\> stands for the 
installation directory chosed to install the accompanying software and 
\c bky.c, \c bky.h, \c bkyact.c, \c bkyact.h, and \c main.c are the 
platform-independent files. Thus, the code is actually identical in all 
Blinky versions, such as the Windows version, Linux version, arm-cortex 
version, and so on.

- \ref blinky_sm
- \ref blinky_ao
- \ref blinky_init
- \ref blinky_run

<HR>
\section blinky_sm State machine

The following figure shows the state machine associated with Blinky 
active object, which clearly shows the life cycle consisting of states 
\c "led_on", and \c "led_off".

\anchor blinky_fig1
\image html rkh_blinky.png "Blinky state machine"

\li ( 1) 	The \c blinky_init() function defines the topmost initial 
			transition in the my state machine. The function prototype is 
			defined as RKHINIT_T. This argument is (optional), thus it could 
			be declared as NULL. 
\li ( 2) 	The timer \c bkytim is declared with the RKHT_T data type and is 
			defined with the rkh_tim_init() RKH service. The timer is 
			initialized in a non-active state (stopped). In this case, a 
			subsequent start service call is necessary to get the timer 
			actually started.
\li ( 3) 	Turn on the LED and trigger the \c bkytim timer as oneshot to 
			expire in \c LED_ON_TIME milliseconds.
\li ( 4-8) 	Upon receiving the TIMEOUT event, the Blinky re-trigger the 
			\c bkytim timer to expire in \c LED_OFF_TIME milliseconds, turn 
			off the LED, and increments the counter.	
\li ( 9-10)	Turn off the LED and trigger the \c bkytim timer as oneshot to 
			expire in \c LED_OFF_TIME milliseconds.

\note
The notation of UML Statecharts is not purely visual. Any nontrivial state 
machine requires a large amount of textual information (e.g., the 
specification of actions and guards). The exact syntax of action and guard 
expressions isnÂ’t defined in the UML specification, so many people use 
either structured English or, more formally, expressions in an implementation 
language such as C [Douglass]. In practice, this means that UML Statechart 
notation depends heavily on the specific programming language.

The \ref bky_c "bky.c" file implements the state machine of Blinky active 
object, which illustrates some aspects of implementing state machines with 
RKH framework. Please correlate this implementation with the state diagram 
shown above. On the other hand, the header file \ref bky_h "bky.h" contains 
the definitions of object structures related to the state machine. \n

\anchor bky_c 
<STRONG> \"bky.c\" - State machine representation </STRONG>
\code
#include "rkh.h"


/*
 *	Include file of HSM definitions.
 */

#include "bky.h"


/*
 *	Include file of action/guard definitions
 */

#include "bkyact.h"


/*
 *	Defines SMA (active object) 'blinky'.
 */

RKH_SMA_CREATE( BKYSM_T, 0, blinky, 0, HCAL, &led_on, blinky_init, NULL );


/* Defines the "led_on" state */
RKH_CREATE_BASIC_STATE( led_on, 0, NULL, NULL, RKH_ROOT, NULL );

/* led_on's state transition table */
RKH_CREATE_TRANS_TABLE( led_on )
	RKH_TRREG( TIMEOUT, NULL, 	blinky_led_off,		&led_off ),
RKH_END_TRANS_TABLE

/* Defines the "led_off" state */
RKH_CREATE_BASIC_STATE( led_off, 1, NULL, NULL, RKH_ROOT, NULL );

/* led_off's state transition table */
RKH_CREATE_TRANS_TABLE( led_off )
	RKH_TRREG( TIMEOUT,	NULL,	blinky_led_on,		&led_on ),
RKH_END_TRANS_TABLE
\endcode

\n The related actions (entry, exit, guard, and state transition) to be 
executed by the state machine are implemented and declared in the 
\ref bkyact_c "bkyact.c" and \ref bkyact_h "bkyact.h" file, respectively. 
Note that the \c rkhcfg.h file defines the prototypes of them. \n

\anchor bkyact_c 
<STRONG> \"bkyact.c\" - Actions </STRONG>
\code
#include "rkh.h"
#include "bky.h"
#include "bkyact.h"
#include "bsp.h"


#define CBKY( sm_ )		(( BKYSM_T* )(sm_))


/*
 * 	Declare and allocate the 'e_tout' event.
 * 	The 'e_tout' event with TIMEOUT signal never changes, so it can be 
 * 	statically allocated just once by means of RKH_DCLR_STATIC_EVENT() macro.
 */

static RKH_DCLR_STATIC_EVENT( e_tout, TIMEOUT );


/*
 * 	Declare and allocate the 'blktim' timer, which is responsible for 
 * 	toggling the LED posting the TIMEOUT signal event to active object 
 * 	'blinky'.
 */

RKHT_T bkytim;


/*
 *	Defines HSM init function
 */

void 
blinky_init( const struct rkhsma_t *sma )
{
	rkh_tim_init( &bkytim, &e_tout, NULL );
	blinky_led_on( sma, NULL  );	
}


/*
 *	Defines transition action functions
 */

void
blinky_led_on( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)pe;

	rkh_tim_oneshot( &bkytim, blinky, LED_ON_TIME );
	bsp_led_on();
	++CBKY(sma)->cnt;
}


void
blinky_led_off( const struct rkhsma_t *sma, RKHEVT_T *pe )
{
	(void)sma;
	(void)pe;

	rkh_tim_oneshot( &bkytim, blinky, LED_OFF_TIME );
	bsp_led_off();
}
\endcode

\anchor bkyact_h 
\n <STRONG> \"bkyact.h\" - Action declarations </STRONG>
\code
#ifndef __BKYACT_H__
#define __BKYACT_H__


#include "rkh.h"


/*
 *	Defines HSM init function
 */

void blinky_init( const struct rkhsma_t *sma );


/*
 *	Defines transition action functions
 */

void blinky_led_on( const struct rkhsma_t *sma, RKHEVT_T *pe );
void blinky_led_off( const struct rkhsma_t *sma, RKHEVT_T *pe );


#endif
\endcode

<HR>
\section blinky_ao Signals, events, and active objects

\n In RKH, signals are typically enumerated constants and events with 
parameters are structures derived from the RKHEVT_T base structure. The next 
listing shows signals and events used in the Blinky application 
(\ref bky_h "bky.h"). \n

\anchor bky_h 
<STRONG> \"bky.h\" - Signals, events, and active objects </STRONG>
\code
#ifndef __BKY_H__
#define __BKY_H__


#include "rkh.h"


#define LED_OFF_TIME			RKH_TIME_SEC( 2 )
#define LED_ON_TIME				RKH_TIME_SEC( 2 )


/*
 * 	Signals.
 */

enum
{
	TIMEOUT,		/* 'blktim' timeout */
	TERMINATE,		/* press the key escape on the keyboard */
	BKY_NUM_EVENTS
};


typedef struct
{
	RKHSMA_T sma;	/* base structure */
	rkhui8_t cnt;	/* private member */
} BKYSM_T;			/* SMA derived from RKHSMA_T structure */


/*
 *	Declare HSM.
 */

RKH_SMA_DCLR( blinky );


/*
 *	Declare states and pseudostates.
 */

RKH_DCLR_BASIC_STATE	led_off, led_on;


#endif
\endcode

\n <HR>
\section blinky_init Initializing and starting the application

Most of the system initialization and application startup can be written 
in a platform-independent way. \n

\anchor main_c 
<STRONG> \"main.c\" - main() function </STRONG>
\code
main.c
#include "rkh.h"
#include "rkhtrc.h"
#include "bsp.h"
#include "bky.h"
#include "bkyact.h"


#define QSTO_SIZE			4

static RKHEVT_T *qsto[ QSTO_SIZE ];
extern RKHT_T bkytim;


int
main( int argc, char *argv[] )
{
	bsp_init( argc, argv );

	/* set trace filters */
	RKH_FILTER_ON_GROUP( RKH_TRC_ALL_GROUPS );
	RKH_FILTER_ON_EVENT( RKH_TRC_ALL_EVENTS );
	RKH_FILTER_OFF_EVENT( RKH_TE_TIM_TOUT );
	RKH_FILTER_OFF_EVENT( RKH_TE_SM_STATE );
	RKH_FILTER_OFF_SMA( blinky );

	rkh_init();
	RKH_TRC_OPEN();

	RKH_TR_FWK_OBJ( blinky );
	RKH_TR_FWK_OBJ( &blinky->equeue );
	RKH_TR_FWK_OBJ( &led_on );
	RKH_TR_FWK_OBJ( &led_off );
	RKH_TR_FWK_OBJ( &bkytim );
	RKH_TR_FWK_SIG( TIMEOUT );

	rkh_sma_activate( blinky, (const RKHEVT_T **)qsto, QSTO_SIZE, CV(0), 0 );
	rkh_enter();

	RKH_TRC_CLOSE();
	return 0;
}
\endcode

\n <HR>
\section blinky_run Running on various platforms

As said before, the only platform-dependent file is the board support package 
(BSP) definition. Each of supported platforms defines its own \c bsp.c and 
\c bsp.h files, which are contained in the proper directory, for example, the 
BSP for the Blinky application on Windows 32 (Visual Studio 2008) with a 
simple cooperative scheduler is located in 
\c \<rkh\>\\demo\\cross\\blinky\\platform\\80x86\\win32_st\\vc08\\. 

<TABLE	align="center" valign="middle" height=60% width=70% cellSpacing=4 
		cellPadding=4 border=0>

	<TR bgColor="#c8cedc">
		<TH><B>&nbsp; CPU Architecture </B></TH>
		<TH><B>&nbsp; Manufacturer </B></TH>
		<TH><B>&nbsp; MCU </B></TH>
		<TH><B>&nbsp; Evaluation Board </B></TH> 
		<TH><B>&nbsp; Toolchain </B></TH> 
		<TH><B>&nbsp; Comments </B></TH> 
		<TH><B>&nbsp; Notes </B></TH> 
	</TR>

	<TR bgColor="#bbffff" align="center" valign="middle" >
		<TD rowspan="3"> ARM - Cortex </TD>
		<TD> NXP </TD>
		<TD> <A HREF="http://www.nxp.com/products/microcontrollers/cortex_m3/
		LPC1769FBD100.html">LPC1769</A> </TD>
		<TD> <A HREF="http://www.embeddedartists.com/products/lpcxpresso/
		lpc1769_xpr.php">LPCXpresso</A> </TD>
		<TD> Codered </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_lpcx1769 "readme" </TD>
	</TR>

	<TR bgColor="#bbffff" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		taxonomy.jsp?code=K60_ETHERNET_CRYPTO_MCU&
		tid=mKOvp">Kinetis K60</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=TWR-K60N512&tid=vanRED">TWR-K60N512</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD>  </TD>
	</TR>

	<TR bgColor="#bbffff" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/
		site/prod_summary.jsp?code=KL2">Kinetis KL</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=FRDM-KL25Z">Freedom</A> </TD>
		<TD> Codewarrior v10.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD>  </TD>
	</TR>

	<TR bgColor="#99ff99" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> Coldfire V1 </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=MCF51QE">MCF51QE128</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=DEMOQE128">DEMOQE128</A> </TD>
		<TD> Codewarrior v6.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_demoqe128_cfv1 "readme" </TD>
	</TR>

	<TR bgColor="#bbffff" align="center" valign="middle" >
		<TD> Freescale </TD>
		<TD> S08 </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/
		site/prod_summary.jsp?code=S08QE">S08QE128</A> </TD>
		<TD> <A HREF="http://www.freescale.com/webapp/sps/site/
		prod_summary.jsp?code=DEMOQE128">DEMOQE128</A> </TD>
		<TD> Codewarrior v6.x </TD>
		<TD> Native cooperative scheduler </TD>
		<TD> \ref cross_demoqe128_s08 "readme" </TD>
	</TR>

	<TR bgColor="#99ff99" align="center" valign="middle" >
		<TD rowspan="2"> 80x86 </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> <A HREF="http://www.microsoft.com/en-us/download/
		details.aspx?id=5555">Visual Studio C++ 2010 </A> </TD>
		<TD> Win32 cooperative scheduler simulation </TD>
		<TD>  </TD>
	</TR>

	<TR bgColor="#99ff99" align="center" valign="middle">
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> --- </TD>
		<TD> GNU </TD>
		<TD> Linux cooperative scheduler simulation </TD>
		<TD>  </TD>
	</TR>
</TABLE>

Prev: \ref cross "Cross-platform examples"\n
*/
