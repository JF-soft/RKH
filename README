
Overview

RKH is a generic, flexible, modular, highly portable, ANSI-C compliant, 
and open-source development tool for implementing hierarchical 
state machines based on modern state machine concepts. This modern 
techniques are used to give an abstract description of the dynamic 
behavior of a system in a substantial manner.

------------------------------------------------------------------------------

The main features of RKH

- State machines representation is based on state tables.
- Representing a state machine with RKH is intuitive, and easy.
- Reflects the state diagram without obfuscation.
- The RKH application are highly maintainable.
- Provide the test harness to develop based on test.
- Easy to integrate with any event queuing and dispatching mechanism.
- Useful in embedded systems.
- The most of the RKH implementation is independent of any particular CPU, 
operating system, or compiler.
- Flexible and user-configurable code generation.
- Very small footprint.
- Include a dispatching event mechanism based on active object's priority.
- Include a queue module
- Include a software timer module.
- Include a fixed-size memory block module.
- Include a native tracing tool.
- Support hierarchically nested states, and flat state machine.
- Support multiple state machines.
- Support final state.
- Support junction, branch and history (shallow and deep) pseudostates.
- Support compound transitions with guards.
- Support submachine state.
- Support local, internal and completion transitions.
- Support entry and exit actions.
- Implement the traditional transition sequence.
- Include mechanism for deferring events.
- Support event dispatching with parameters.
- Include dynamic events.
- Support a easy way to use events with arguments.
- Support systems-friendly assertion macros like assert, allege, error, 
require, and ensure.

------------------------------------------------------------------------------

Purpose and inspiration

For many years, I had been used the traditional state-machine concepts 
based on state-table strategy for modeling the dynamic behavior of several 
reactive-systems, in many industries. Over the years, this implementation 
was expanding its abilities to support system requirements increasingly 
complex, achieving hierarchically nested states, pseudostates, compound 
transitions, and more, proposed by Harel Statecharts.

The RKH not implements neither entire UML specs. nor entire Statechart 
specs. Instead, the RKH intention is to support just enough basic concepts 
of that powerful tools to facilitate the reactive-system modeling holding 
a solid, and efficient implementation. Broadly speaking, the RKH 
implementation has been designed from the ground up to be used in 8-bits 
platforms but can be easily adapted to 16 or 32-bits platforms.

------------------------------------------------------------------------------

Other implementations

Open-source frameworks that support Statecharts.

Quantum Leap - http://www.state-machine.com/ 
Intelliwizard - http://www.intelliwizard.com/ 

------------------------------------------------------------------------------

Licensing

Copyright (C) 2010 Leandro Francucci. All rights reserved.

RKH is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.

RKH is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with RKH package. If not, see <http://www.gnu.org/licenses/>.

(*) Observe that, the GPLv3 can be used for research & development and educational purposes (academic purposes). 
(**) When the source code of your application should not be published under the GNU GPLv3 license (closed source code), please, contact contact me. See Contact information section.

------------------------------------------------------------------------------

Contact information:

RKH web site: http://sourceforge.net/projects/rkh-reactivesys/
e-mail: francuccilea@gmail.com

------------------------------------------------------------------------------

RKH Release notes

Changes between V2.4.4 and V2.4.5 released 04/25/2016 

- The API for RKH_CREATE_DEEP_HISTORY_STATE() and 
  RKH_CREATE_SHALLOW_HISTORY_STATE() changed. Added arguments to set 
  (optional) the history default transition. However, those macros are now 
  deprecated and not recommended for new designs. It remains supported for 
  backwards compatibility.

- Fixed a old bug at rkh_sm_dispatch() function in rkh.c file related with 
  entry and exited states on a loop transition. The implemented solution have 
  adopted the UML's local transition feature. 

- Added support for code beautifier Uncrustify in /tools/uncrustify, to be 
  used as a code formatting tool according to RKH rules. Also, included source 
  and header file templates.
- Reformatted source and header files in /sources and /sources/include.
- Added support for TDD with Unity + Cmock + Trazer. The directory /tests 
  includes the related files.
- Added #RKH_CFG_HOOK_PUT_TRCEVT_EN configuration option to include the new bsp 
  dependent function rkh_hook_putTrcEvt().
- Refactored trace module (/tests/trace), state machine module (/tests/sm) 
  and trazer (/tests/utrazer) through the test harness. It implies various 
  performance improvements, memory usage reduction, better documentation, and 
  learning tests.
- Removed NULL macro usage from rkh.h file, and thus <stdlib.h> inclusion.
- Improved doc files (doxygen) and comments.
    - Added deprecated list.
    - Enhanced module section by including the configuration, trace, test,
      and API referecen manual sections.
- Added test suite of state machine module.
- Multiple enabled transitions (same trigger) with mutually exclusive guards 
  according to UML is now supported.
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- Completion transition (also as known as null transition) and completion 
  event in simple and composite states is now supported.
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- Final state in composite states is now supported.
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- The default transition (also as known as initial transition) in a composite 
  state can have its own associated behavior (effect) is now supported.
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- Added macro RKH_CREATE_COMP_REGION_STATE() to instantiate a composite state 
  with a single region, including its own initial pseudostate, history 
  (shallow or deep type) pseudostate, as well as its own final state.
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- Multiple enabled transitions (same trigger) with mutually exclusive guards 
  according to UML is now supported. This usage of this feature is 
  demonstrated through various and provided learning tests.
- A state machine is now allowed to be instantiated regardless of an active 
  object instance. It is very useful to create reactive parts (or orthogonal 
  regions) of composite active objects. Also, by means of 
  RKH_CFG_SMA_SM_CONST_EN option a state machine instance could be allocated 
  into ROM or RAM. It is useful to dynamic allocation. This usage of this 
  feature is demonstrated through various and provided learning tests.
- Polimorphic active objects with "virtual" table (in C) is now supported. It 
  is composed as activate, task, post_fifo, and post_lifo operations. 
  This usage of this feature is demonstrated through various and provided 
  learning tests.
- Added runtime constructors for active object and state machine classes for 
  multiple and single instances. This usage of this feature is demonstrated 
  through various and provided learning tests.
- Added RKH_CFG_SMA_VFUNCT_EN and RKH_CFG_SMA_RT_CTOR_EN options to set the 
  active object as polymorphic and to use the runtime constructors of 
  RKH_SMA_T/RKH_SM_T classes. This usage of this feature is demonstrated 
  through various and provided learning tests.
- Template files for dealing with implementation and specification of active 
  objects is now added to /template.
- Added RKH_DECLARE_TR_TBL(), RKH_INIT_BASIC_STATE(), and 
  RKH_INIT_COMPOSITE_STATE() macros to derive a state (basic or composite) 
  class to any other using single inheritance in C by literally embedding 
  the base type (or super-class), RKHSBSC_T or RKHSCMP_T, as the first 
  member of the derived structure.

- The RKH_CREATE_DEEP_HISTORY_STATE() and RKH_CREATE_SHALLOW_HISTORY_STATE() 
  macros are now deprecated and not recommended for new designs. It remains 
  supported for backwards compatibility.

- Added a port to be exclusively used in the x86 test harness in 
  /source/portable/test directory, tagged as "__TEST__".
